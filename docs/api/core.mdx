---
sidebar_position: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Core

[NPM](https://npmjs.com/package/@civet/core) | [GitHub](https://github.com/civet-org/core)

```bash
npm install @civet/core
```

The core module provides Civet's base functionality.

## `ConfigContext`

React context for providing shared configuration to core components.

### Context

| Name         | Type                            | Description |
| ------------ | ------------------------------- | ----------- |
| dataProvider | [`DataProvider`](#dataprovider) |             |

### Related

[`<ConfigProvider>`](#configprovider), [`<ConfigConsumer>`](#configconsumer), [`useConfigContext`](#useconfigcontext)

## `<ConfigProvider>`

Context provider for the [`ConfigContext`](#configcontext).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    <ConfigProvider dataProvider={provider}>...</ConfigProvider>
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { ConfigProvider } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Props

| Name         | Type                            | Description |
| ------------ | ------------------------------- | ----------- |
| dataProvider | [`DataProvider`](#dataprovider) |             |

### Related

[`ConfigContext`](#configcontext), [`<ConfigConsumer>`](#configconsumer), [`useConfigContext`](#useconfigcontext)

## `<ConfigConsumer>`

Context consumer for the [`ConfigContext`](#configcontext).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    <ConfigConsumer>
      {(context) => ...}
    </ConfigConsumer>
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { ConfigConsumer } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Related

[`ConfigContext`](#configcontext), [`<ConfigProvider>`](#configprovider), [`useConfigContext`](#useconfigcontext)

## `useConfigContext`

Context consumer for the [`ConfigContext`](#configcontext).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    const context = useConfigContext();
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { useConfigContext } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Function arguments

None

### Return type

| Type     | Description                       |
| -------- | --------------------------------- |
| `object` | [ConfigContext](#configcontext) |

### Related

[`ConfigContext`](#configcontext), [`<ConfigProvider>`](#configprovider), [`<ConfigConsumer>`](#configconsumer)

## `<Resource>`

Makes data from an [`DataProvider`](#dataprovider) available to its descendants using a [`<ResourceProvider>`](#resourceprovider).

Necessary configuration that is not directly specified is taken from the nearest [`<ConfigProvider>`](#configprovider).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    <Resource name="persons" query={{ city: "New York" }}>
      ...
    </Resource>
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { Resource } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Props

| Name         | Type                            | Description                                                                                                                                                                                         |
| ------------ | ------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name         | `string` **(required)**         | Resource name                                                                                                                                                                                       |
| query        | `any`                           | Query filter                                                                                                                                                                                        |
| empty        | `boolean`                       | Whether to prevent fetching data                                                                                                                                                                    |
| options      | `object`                        | [`DataProvider`](#dataprovider) options for requests                                                                                                                                                |
| dataProvider | [`DataProvider`](#dataprovider) | [`DataProvider`](#dataprovider) to be used for requests                                                                                                                                             |
| persistent   | `boolean` &#124; `"very"`       | Whether stale data should be retained during the next request - this only applies if neither `dataProvider` nor `name` have changed, unless set to `"very"` where also `name` changes are preserved |

### Context

See [`<ResourceProvider>`](#resourceprovider)

### Related

[`<ResourceProvider>`](#resourceprovider), [`<ResourceConsumer>`](#resourceconsumer), [`useResourceContext`](#useresourcecontext)

## `<ResourceProvider>`

Provides resource context to its descendants using React's context API.

In most cases you should use [`<Resource>`](#resource) instead.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    <ResourceProvider value={resourceContext}>...</ResourceProvider>
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { ResourceProvider } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Props

| Name  | Type     | Description      |
| ----- | -------- | ---------------- |
| value | `object` | Resource context |

### Context

| Name         | Type                                                   | Description                                                                                        |
| ------------ | ------------------------------------------------------ | -------------------------------------------------------------------------------------------------- |
| name         | `string`                                               | Resource name                                                                                      |
| query        | `any`                                                  | Query filter                                                                                       |
| options      | `object`                                               | [`DataProvider`](#dataprovider) options used for the request                                       |
| dataProvider | [`DataProvider`](#dataprovider)                        | [`DataProvider`](#dataprovider) to be used for requests                                            |
| request      | `string`                                               | Unique identifier for the current request - the value can be compared alphanumerically             |
| revision     | `string`                                               | Unique identifier for the current request's revision - the value can be compared alphanumerically  |
| data         | `any[]`                                                | The actual data                                                                                    |
| meta         | `object`                                               | Metadata                                                                                           |
| error        | `Error` &#124; `boolean`                               | Error information about the most recent request, or `true` if no further information is available  |
| isEmpty      | `boolean`                                              | Whether fetching data is prevented                                                                 |
| isLoading    | `boolean`                                              | Whether another query is currently being executed                                                  |
| isIncomplete | `boolean`                                              | Whether the current query is still being executed                                                  |
| isInitial    | `boolean`                                              | Whether the current query is the first non failing query                                           |
| isStale      | `boolean`                                              | Whether the current data is stale                                                                  |
| notify       | `() => Promise<{ request: string, revision: string }>` | Callback to reload the current request - Returns a Promise with the resulting request and revision |

### Related

[`<Resource>`](#resource), [`<ResourceConsumer>`](#configconsumer), [`useResourceContext`](#useresourcecontext)

## `<ResourceConsumer>`

Context consumer for [`<ResourceProvider>`](#resourceprovider).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    <ResourceConsumer>
      {(context) => ...}
    </ResourceConsumer>
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { ResourceConsumer } from "@civet/core";
    ```
  </TabItem>
</Tabs>

## `useResourceContext`

Context hook for [`<ResourceProvider>`](#resourceprovider).

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    const resourceContext = useResourceContext();
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { useResourceContext } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Function arguments

None

### Return type

| Type     | Description                           |
| -------- | ------------------------------------- |
| `object` | [Resource context](#resourceprovider) |

## `BaseDataProvider`

DataProvider base class.

When implementing your own DataProvider, usually you would prefer [`DataProvider`](#dataprovider) over this class, as it already provides some general implementations.

<Tabs>
  <TabItem value="import" label="Import">
    ```js
    import { BaseDataProvider } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Class members

| Name            | Arguments                                                                                                                                                                                                    | Return Type               | Description                                                                                                             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| subscribe       | resourceName: `string`, handler: `() => void`                                                                                                                                                                | unsubscribe: `() => void` | Subscribe to data change notifications                                                                                  |
| notify          | resourceName: `string`                                                                                                                                                                                       | `void`                    | Notify data changes                                                                                                     |
| get             | resourceName: `string`, query: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta)                                                                                                               | `Promise<any[]>`          | Get data (at once &#124; uses `handleGet` internally)                                                                   |
| continuousGet   | resourceName: `string`, query: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta), callback: `(error: any, complete: boolean, data: any[]) => void`, abortSignal: [`AbortSignal`](#abortsignal) | `void`                    | Get data (continuously &#124; uses `handleGet` internally)                                                              |
| create          | resourceName: `string`, data: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta)                                                                                                                | `Promise<void>`           | Create data (uses `handleCreate` internally)                                                                            |
| update          | resourceName: `string`, query: `any`, data: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta)                                                                                                  | `Promise<void>`           | Update data (uses `handleUpdate` internally)                                                                            |
| patch           | resourceName: `string`, query: `any`, data: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta)                                                                                                  | `Promise<void>`           | Patch data (uses `handlePatch` internally)                                                                              |
| remove          | resourceName: `string`, query: `any`, options: `object`, meta: `object` &#124; [`Meta`](#meta)                                                                                                               | `Promise<void>`           | Remove data (uses `handleRemove` internally)                                                                            |
| transition      | nextData: `any[]`, prevData: `any[]`, context: `object`, prevContext: `object`                                                                                                                               | `any[]`                   | Transition between the previous and current `data` array (see caveats for more details)                                 |
| recycleItems    | nextData: `any[]`, prevData: `any[]`, context: `object`, prevContext: `object`                                                                                                                               | `any[]`                   | Recycle unchanged items to prevent unneeded rerenders (see caveats of [`DataProvider`](#dataprovider) for more details) |
| compareRequests | prev: `object`, next: `object`                                                                                                                                                                               | `boolean`                 | Compare requests for equality - can be used to customize the comparison of requests when the props of a Resource change |
| extend          | `{ resource: (resourcePlugin: ReactComponent) => void }`                                                                                                                                                     | `void`                    | Extend Civet with custom functionality (see [Extending Civet](/docs/guides/extending#dataprovider) for more details)    |

### Abstract members

| Name         | Arguments                                                                                   | Return Type                                                                                                                                 | Description                                                                                   |
| ------------ | ------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| handleGet    | resourceName: `string`, query: `any`, options: `object`, meta: [`Meta`](#meta)              | `any[]` &#124; `Promise<any[]>` &#124; `(callback: (error: any, complete: boolean, data: any[]) => void, abortSignal: AbortSignal) => void` | A callback function can be returned to support continuous gets (see caveats for more details) |
| handleCreate | resourceName: `string`, data: `any`, options: `object`, meta: [`Meta`](#meta)               | `void` &#124; `Promise<void>`                                                                                                               |                                                                                               |
| handleUpdate | resourceName: `string`, query: `any`, data: `any`, options: `object`, meta: [`Meta`](#meta) | `void` &#124; `Promise<void>`                                                                                                               |                                                                                               |
| handlePatch  | resourceName: `string`, query: `any`, data: `any`, options: `object`, meta: [`Meta`](#meta) | `void` &#124; `Promise<void>`                                                                                                               |                                                                                               |
| handleRemove | resourceName: `string`, query: `any`, options: `object`, meta: [`Meta`](#meta)              | `void` &#124; `Promise<void>`                                                                                                               |                                                                                               |

### Caveats

#### Abstract functions

The functions `get`, `create`, ... internally invoke their corresponding abstract counterparts `handle...` and perform generic validation on their parameters and return values. Therefore, you should not just override them, but implement the abstract `handle...` methods instead.

#### continuousGet & transitioning

`dataProvider.get` resolves when the complete data is collected.
This is fine when resolving the data is really fast but can be troublesome when you want to load large data sets e.g. from a backend over a slow internet connection.
You can implement your DataProvider to support continuous data fetching by returning a callback function from `handleGet` rather than the data itself.
This allows you to forward partial data to the Resource component (or other compatible clients) even if the fetch has not yet been completed.

It can be helpful to allow a transition between several updates of the component, e.g. to keep the order of the elements while the retrieval is still running.
The `<Resource>` component supports this by calling the `DataProvider`'s `transition` method each time it resolves new data. The function is called before `recycleItems`, so you don't have to worry about it when implementing the transition.

#### Metadata

The `meta` attribute provided to `DataProvider`'s functions can have multiple applications.
It is an interface which can be used to pass additional meta information beside the actual data to its underlying consumers.

When a `get` request is made by a [`<Resource>`](#resource) component, the `meta` object has the following functions:

- Its contents are published to the consumers of the [`<Resource>`](#resource) via the [Resource context](#resourceprovider).
- Its contents are preserved between multiple revisions of a request and thereas can be used to provide information to subsequent queries or utility functions like `transition` or `recycleItems`. When the [`<Resource>`](#resource) is in persistent mode, the information is also preserved between multiple requests.
- The special key `persistant` (e.g. `meta.set('persistent', true)`) can be used to force the Resource's persistent state. This can be especially useful when the persistant state is required for performance optimizations. It takes the same values as [`<Resource>`](#resource)'s `persistent` prop.

As the contents of `meta` may be preserved between multiple requests or revisions, it may be necessary to clean it up in your DataProvider's `get` function. Please see [`Meta`](#meta) for more information.

## `DataProvider`

Default DataProvider implementation (based on [`BaseDataProvider`](#basedataprovider)).

<Tabs>
  <TabItem value="usage" label="Usage" default> 
    ```js
    class CustomProvider extends DataProvider {
      handleGet(resource, query, options, meta) {
        return ...;
      }
    }

    const provider = new CustomProvider();
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { DataProvider } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Class members

| Name                         | Arguments                        | Return Type | Description                                                                                                                                           |
| ---------------------------- | -------------------------------- | ----------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| recycleItemsUniqueIdentifier | item: `any`                      | `string`    | Should return a string which is uniquely identifying the same item accross multiple requests.                                                         |
| recycleItemsIsUnchanged      | nextItem: `any`, prevItem: `any` | `boolean`   | Return `true` if the item was not changed at all, e.g. both versions are completely equal. (You can do so by comparing ETags or similar if available) |

### Caveats

#### BaseDataProvider

Please note that `DataProvider` is an implementation of [`BaseDataProvider`](#basedataprovider), so make sure to check the Caveats section there, too.

#### recycleItems

React offers tools to avoid unnecessary component updates, including `React.Component.shouldComponentUpdate`, `React.PureComponent` and `React.memo`.
These tools check whether the props of a component have changed since the previous render to determine if the component needs to be updated again.
The fastest way to achieve this would be to use `Object.is`, which behaves like JavaScript's strict comparison operator `===` except for a few differences.
This function works great for primitives like strings or numbers, but doesn't work like we would expect it to when used with objects and arrays.
This is because objects and arrays (which in fact are objects as well) are compared by their memory addresses instead of their contents. See the example below:

```js
const a = { x: 1 };
const b = { x: 1 };
const c = a;
a === b; // -> false: not the same memory address
a === c; // -> true: same memory address
```

`recycleItems` attempts to fix this issue.
It is internally called by the [`<Resource>`](#resource) component after each fetch.
The function compares the previous items with the next ones and attempts to reapply all unchanged items from the previous array to the new one.
As a result, the following checks should succeed:

- array equality
  - if one or more items differ (compared by value): `prevData !== nextData`
  - if items were added or removed: `prevData !== nextData`
  - if the order of the arrays differs: `prevData !== nextData`
  - else: `prevData === nextData`
- item equality
  - if an item differs (compared by value): `prevItem !== nextItem`
  - else (even if it was reordered in the array): `prevItem === nextItem`

However, the default implementation may be expensive in regard to performance and may be inaccurate as it creates a hash over each item as its unique identifiers.
This is why, if possible, you should improve it with a faster comparing approach by overriding the methods `recycleItemsUniqueIdentifier` and `recycleItemsIsUnchanged`. You can also completely ditch the default implementation by implementing your own version of `recycleItems` which may be required if you cannot build a unique identifier.

## `isDataProvider`

Identifies [`DataProvider`](#dataprovider) instances.

<Tabs>
  <TabItem value="usage" label="Usage" default>        
    ```js
    const ds = new DataProvider();

    if (!isDataProvider(ds)) {
      throw new Error("Should be a DataProvider instance");
    }
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { isDataProvider } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Function arguments

| Name         | Type  | Description              |
| ------------ | ----- | ------------------------ |
| dataProvider | `any` | The object to be checked |

### Return type

| Type      | Description                                                              |
| --------- | ------------------------------------------------------------------------ |
| `boolean` | Whether `dataProvider` is an instance of [`DataProvider`](#dataprovider) |

## `dataProviderPropType`

PropType for [`DataProvider`](#dataprovider) instances.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    const propTypes = {
      optional: dataProviderPropType,
      required: dataProviderPropType.isRequired,
    };
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { dataProviderPropType } from "@civet/core";
    ```
  </TabItem>
</Tabs>


## `createPlugin`

Creates a plugin from the provided configuration function.

See [Extending Civet](/docs/guides/extending#plugins) for further information.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    const plugin = createPlugin((BaseDataProvider) => {
      function ResourceHook({ ...props, context, children }) {
        return (
          <ReactComponent>
            {children({ ...context, extendedContext: 123 })}
          </ReactComponent>
        );
      }

      class ExtendedDataProvider extends BaseDataProvider {
        extend(extend) {
          // This is necessary for the base class to work properly:
          super.extend(extend);

          // Register a Resource hook component
          extend.resource(ResourceHook);
        }

        // ... custom DataProvider functionality
      }

      return ExtendedDataProvider;
    });

    const DataProviderWithPlugin = plugin(SomeDataProvider);
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { createPlugin } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Function arguments

| Name             | Type                                               | Description                                                     |
| ---------------- | -------------------------------------------------- | --------------------------------------------------------------- |
| pluginDefinition | `(BaseDataProvider: DataProvider) => DataProvider` | A function that returns an extended version of BaseDataProvider |

### Return type

| Type                             | Description |
| -------------------------------- | ----------- |
| `(DataProvider) => DataProvider` | The plugin  |

## `compose`

Composes the specified single-argument functions from right to left.

This can be especially useful when applying multiple plugins to a DataProvider.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```jsx
    const DataProviderWithPlugins = compose(
      pluginA,
      pluginB,
      pluginC
    )(SomeDataProvider);
    // This is the same as: pluginA(pluginB(pluginC(SomeDataProvider)))
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { compose } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Function arguments

| Name   | Type              | Description                  |
| ------ | ----------------- | ---------------------------- |
| ...fns | `(a: any) => any` | The functions to be composed |

### Return type

| Type              | Description            |
| ----------------- | ---------------------- |
| `(a: any) => any` | The composed functions |

## `Notifier`

Interface for handling client side notification events.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    // Basic usage
    const notifier = new Notifier();
    function handler() {
      console.log("Subscriber was notified");
    }
    const unsubscribeHandler = notifier.subscribe(handler);
    console.log(notifier.isSubscribed(handler)); // true
    notifier.trigger();
    unsubscribeHandler();
    console.log(notifier.isSubscribed(handler)); // false

    // You can pass arguments to the handlers
    const notifier = new Notifier();
    notifier.subscribe((a, b, c) => {
      console.log("Notified:", a, b, c);
    });
    notifier.trigger(true, 2, "test");
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { Notifier } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Class members

| Name         | Arguments                         | Return Type               | Description                                                          |
| ------------ | --------------------------------- | ------------------------- | -------------------------------------------------------------------- |
| subscribe    | handler: `(...args: any) => void` | unsubscribe: `() => void` | Subscribe to notifications                                           |
| isSubscribed | handler: `(...args: any) => void` | `boolean`                 | Whether the provided handler is currently subscribed to the notifier |
| trigger      | `...args: any`                    | `void`                    | Notify all currently subscribed handlers                             |

## `ChannelNotifier`

[`Notifier`](#notifier) that supports multiple separate event channels.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    // Basic usage
    const notifier = new ChannelNotifier();
    function handler() {
      console.log("Subscriber was notified");
    }
    const unsubscribeHandlerFromChA = notifier.subscribe("channel-a", handler);
    console.log(notifier.isSubscribed("channel-a", handler)); // true
    console.log(notifier.isSubscribed("channel-b", handler)); // false
    notifier.trigger("channel-a"); // Only notify channel a
    notifier.trigger(); // Notify all channels
    unsubscribeHandlerFromChA();
    console.log(notifier.isSubscribed("channel-a", handler)); // false

    // You can pass arguments to the handlers
    const notifier = new Notifier();
    notifier.subscribe("channel-a", (a, b, c) => {
      console.log("Notified:", a, b, c);
    });
    notifier.trigger("channel-a", true, 2, "test"); // Notify all channels
    notifier.trigger(null, true, 2, "test"); // Notify all channels
    // Please note that the channel name is not passed to handlers by default.
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { ChannelNotifier } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Class members

| Name         | Arguments                                          | Return Type               | Description                                                                                                                         |
| ------------ | -------------------------------------------------- | ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| subscribe    | handler: `(channel: string, ...args: any) => void` | unsubscribe: `() => void` | Subscribe to notifications on the specified channel                                                                                 |
| isSubscribed | handler: `(channel: string, ...args: any) => void` | `boolean`                 | Whether the provided handler is currently subscribed to the specified channel                                                       |
| trigger      | `channel: string, ...args: any`                    | `void`                    | Notify all handlers currently subscribed to the specified channel (Set the channel to `undefined` or `null` to notify all channels) |

## `AbortSignal`

Interface for handling abort requests.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    // Basic usage
    const signal = new AbortSignal();
    signal.listen(() => {
      console.log("Request has been aborted");
    });
    signal.abort();
    signal.listen(() => {
      console.log(
        "This will be called immediately, as signal has already been aborted"
      );
    });

    // The signal can be locked if it is now longer allowed to be aborted
    const signal = new AbortSignal();
    signal.lock();
    signal.abort(); // No listeners will be notified since the signal is already locked
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { AbortSignal } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Class members

| Name   | Arguments              | Return Type               | Description                                           |
| ------ | ---------------------- | ------------------------- | ----------------------------------------------------- |
| listen | listener: `() => void` | unsubscribe: `() => void` | Listen for abort signals                              |
| abort  |                        | `void`                    | Abort the signal                                      |
| lock   |                        | `void`                    | Lock the signal (The signal can no longer be aborted) |

## `Meta`

Metadata key value map.

<Tabs>
  <TabItem value="usage" label="Usage" default>
    ```js
    // Basic usage
    const meta = new Meta();
    meta.set("test", 1);
    const result = meta.commit();
    console.log(result.test);

    // Meta can be based on an existing object
    const base = {};
    const baseMeta = new Meta(base);
    baseMeta.set("test", 1);
    assert(base.test === baseMeta.get("test"));

    // Meta can create (shallowly) immutable snapshots.
    const previous = { a: 1 };
    const meta = new Meta();
    meta.set("a", 1);
    const unchanged = meta.commit(previous);
    meta.set("a", 2);
    const changed = meta.commit(previous);
    assert(previous === unchanged);
    assert(previous !== changed);
    ```
  </TabItem>

  <TabItem value="import" label="Import">
    ```js
    import { Meta } from "@civet/core";
    ```
  </TabItem>
</Tabs>

### Constructor

| Arguments      | Description                                    |
| -------------- | ---------------------------------------------- |
| base: `object` | All changes get applied to `base` if it is set |

### Class members

| Name    | Arguments                   | Return Type                     | Description                                                                                                                            |
| ------- | --------------------------- | ------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| clear   |                             | `void`                          | Delete all keys from the object                                                                                                        |
| delete  | key: `string`               | `any`                           | Delete the specified key from the object - returns the deleted value                                                                   |
| entries |                             | `([key: string, value: any])[]` | Get all entries from the object                                                                                                        |
| get     | key: `string`               | `any`                           | Get the value for the specified key from the object                                                                                    |
| has     | key: `string`               | `boolean`                       | Check if the object has a value for the specified key                                                                                  |
| keys    |                             | `string[]`                      | Get all keys from the object                                                                                                           |
| set     | key: `string`, value: `any` | `void`                          | Set the value for the specified key. Make sure that values are immutable!                                                              |
| values  |                             | `any[]`                         | Get all values from the object                                                                                                         |
| commit  | prev: `object`              | `object`                        | Get the object as a plain JavaScript object - returns a shallow copy of the current value, or `prev` if provided and if all keys match |

### Caveats

#### Immutability

Meta does NOT make sure that the values you provide are immutable.
If you mutate an array or object which you previously passed to a Meta object, the change is also reflected in this Meta object, even when committed.
Commit only creates a shallow copy of the base object.
To guarantee that your values are truely immutable, it is recommended to use a library like immer or Immutable.js.
